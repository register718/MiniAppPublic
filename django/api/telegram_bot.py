from datetime import date, datetime, timedelta
import telebot
from rest_framework.response import Response
from .serializers import TelegramChatSerializer
from .planExport_view import generateMesseHeader
from .models import TelegramChat, Mini, Messe
from django.contrib.auth.decorators import login_required
from django.contrib.admin.views.decorators import staff_member_required
from django.db.models import Q
from rest_framework.decorators import api_view
from MiniApp.settings import Telegram_API_KEY, logger

telebot.logger.setLevel(telebot.logging.CRITICAL)
bot = telebot.TeleBot(Telegram_API_KEY)

def sendMessage(id, msg, log=True):
  try:
    bot.send_message(id, msg)
  except Exception as e:
    if log:
      logger.critical("Nachricht konnte nicht gesendet werden!")
    print("Nachricht konnte nicht gesendet werden")

def sendReport(msg: str):
  sysAds = TelegramChat.objects.filter(mini__MiniTyp=6)
  for chat in sysAds:
    sendMessage(chat.chatID, msg, log=False)

telebot.logger.addHandler(sendReport)

@api_view(['POST'])
@login_required
@staff_member_required
def telegramRegister(request):
  if 'secretKey' in  request.data and 'mini' in request.data:
    chats = TelegramChat.objects.filter(secretKey=request.data['secretKey'])
    if chats.exists():
      chat = chats.first()
      if not chat.secretKey == 0:
        chat.secretKey = 0
        chat.verified = True
        chat.save()
        for m in request.data['mini']:
          minis = Mini.objects.filter(id=m)
          if minis.exists():
            mini: Mini = minis.first()
            mini.telegram = chat
            mini.save()
        sendMessage(chat.chatID, """Die Registrierung ist abgeschlossen. 
Mit dem Befehl '/startabo', bekommst du eine Benachrichtigung, sobald du eingeteilt bist!
Mit '/stopabo' wird die Benachrichtigung wieder abgestellt""")
        return Response(True)
  return Response(False)

def sendNotificationForMesse(messe: Messe, maskHeute: int, maskeMorgen: int, today: date):
  minis = Mini.objects.filter(Gruppen__Messe=messe, telegram__abo=True, telegram__verified=True, Gruppen__Eingeteilt=True)
  header = generateMesseHeader(messe)
  msg = ""
  if messe.autogenerated:
    # Woche startet erst noch
    if messe.Datum > today:
      msg += "\nDu bist von " + header + " eingeteilt!"
    setInfo = False

    c = 0b1000000
    while c > maskHeute and c & messe.notify == 0:
      c = c >> 1
    if c > maskHeute:
      return
    if maskHeute & messe.notify > 0:
      msg += "\nHeute"
      setInfo = True
    if maskeMorgen & messe.notify > 0:
      msg += " und morgen" if setInfo else '\nMorgen'
      setInfo = True
    if setInfo:
      msg += ' findet ein Gottesdienst statt. Bitte informiere dich im Miniplan, oder Kirchenanzeiger'
    if msg == "":
      return
  else:
    msg = "\nDu bis bald eingeteilt!\n" + header
  
  for mini in minis:
    nachricht = f"Hallo {mini.user.first_name},{msg}"
    sendMessage(mini.telegram.chatID, nachricht)
  
def sendNotification():
  jetzt = datetime.now()
  print(jetzt.weekday())
  maskeHeute =  0b1000000 >> jetzt.weekday()
  maskeMorgen = 0b0100000 >> jetzt.weekday()
  if jetzt.weekday() == 6: #Falls Sontag
    maskeMorgen |= 0b1000000
  add2 = timedelta(days=2)
  add1 = timedelta(days=1)
  add6 = timedelta(days=6)
  messen = Messe.objects.filter(
    Q(autogenerated=True, Datum__range=[jetzt - add6, jetzt + add1]) | Q(autogenerated=False, Datum__range=[jetzt, jetzt + add2]))
  print(messen)
  for m in messen:
    sendNotificationForMesse(m, maskeHeute, maskeMorgen, jetzt.date())
