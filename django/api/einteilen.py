from datetime import timedelta
from django.db.models.query import QuerySet
from .models import Mini, Messe
from .forms import Gruppe
from django.db.models.aggregates import Min, Max, Count, Case, When
from django.db.models.expressions import Value
from django.db.models import Q, F
from random import choice
import datetime

#Standartfestlegung. Wird angepasst
MINIS_PRO_MESSE = 6
OBERMINIS_PRO_MESSE = 2
ABSTAND_EINGETEILT = 7  #Nicht exakt die Tage. Verhalten anders

def __zaehleGruppe__(gruppe: QuerySet[Mini]) -> tuple[int, int]:  #Beachtet keine Passiven, Systemverwalter, Ausgetreten
  #oberminis = gruppe.filter(MiniTyp=0).count()
  #minis = gruppe.count()
  res = gruppe.aggregate(ob_count=Count('id', filter=Q(MiniTyp=0)), mi_count=Count('id'))
  return (res['ob_count'], res['mi_count'])

def __GeneriereGruppe__(mini: Mini) -> QuerySet[Mini]:
  if mini.Geschwister == -1:
     return Mini.objects.filter(id=mini.id)
  return Mini.objects.filter(Geschwister=mini.Geschwister, MiniTyp__lte=2)

def __waehlePassendeGruppe__(minisList: QuerySet, minis_akt: int, oberminis_akt: int) -> tuple[QuerySet[Gruppe], int, int]: #Gruppe, oberminis_gruppe, minisges_gruppe
  global MesseAktuell
  result: QuerySet[Gruppe] = None
  ges_gruppe = 0; ob_gruppe = 0
  #for mini in minisList.iterator():
  resultCount = minisList.count()
  for i in range(0, resultCount):
    time_choice_start = datetime.datetime.now()
    mini: Mini = choice(minisList) #minisList.order_by('?').first() #choice(minisList)
    time_choise_stop = datetime.datetime.now()
    #print('Choice', time_choise_stop - time_choice_start)
    time_gen_start = datetime.datetime.now()
    gruppe: QuerySet[Mini] = __GeneriereGruppe__(mini)
    time_gen_stop = datetime.datetime.now()
    #print("Gen", time_gen_stop - time_gen_start)
    time_count_start = datetime.datetime.now()
    ob_gruppe, ges_gruppe = __zaehleGruppe__(gruppe)
    time_count_stop = datetime.datetime.now()
    #print("Count", time_count_stop - time_count_start)
    if oberminis_akt + ob_gruppe <= OBERMINIS_PRO_MESSE and minis_akt + ges_gruppe <= MINIS_PRO_MESSE:
      time_create_start = datetime.datetime.now()
      result = Gruppe.objects.create(Eingeteilt=True, Messe=MesseAktuell)      # Hier wurde das create wegemacht
      result.Minis.set(gruppe)
      #for m in gruppe:
      #  result.Minis.add(m)
      #result.save()
      time_create_stop = datetime.datetime.now()
      #print("Create", time_create_stop - time_create_start)
      break
    minisList = minisList.exclude(id=mini.id)
  return (result, ob_gruppe, ges_gruppe)

MesseAktuell: Messe = None

def __getMaxMin__(BlockQ, MiniAnno, MiniQ, OberminiQ):
    minimum = MiniAnno.exclude(BlockQ).filter(MiniQ).aggregate(Min('Anzahl'))['Anzahl__min']
    maximum = MiniAnno.exclude(BlockQ).filter(MiniQ).aggregate(Max('Anzahl'))['Anzahl__max']
    minimum_Oberminis = MiniAnno.exclude(BlockQ).filter(OberminiQ).aggregate(Min('Anzahl'))['Anzahl__min']
    maximum_Oberminis = MiniAnno.exclude(BlockQ).filter(OberminiQ).aggregate(Max('Anzahl'))['Anzahl__max']
    return (minimum, maximum, minimum_Oberminis, maximum_Oberminis)

def messeEinteilen(mMesse: Messe):
    time_total = datetime.datetime.now()
    global MesseAktuell, MINIS_PRO_MESSE, OBERMINIS_PRO_MESSE
    # Setzen globaler variablen
    MesseAktuell = mMesse
    messeArt = MesseAktuell.Art
    MINIS_PRO_MESSE = messeArt.MinisInsgesamt
    OBERMINIS_PRO_MESSE = messeArt.OberminisAnzahl
    #Lösche bisherige einteilung
    Gruppe.objects.filter(Messe=MesseAktuell).delete()
    # Blockierte Minis einstellen
    delta = timedelta(days=ABSTAND_EINGETEILT)
    blockOberminis = True
    blockMinis = True
    #print(MesseAktuell.Datum - delta, MesseAktuell.Datum + delta)
    BlockQ = Q(Gruppen__Messe__Datum__range=[MesseAktuell.Datum - delta, MesseAktuell.Datum + delta], Gruppen__Eingeteilt=True)
    OberminiQ = Q(MiniTyp=0)
    MiniQ = Q(Q(MiniTyp=1) | Q(MiniTyp=2))
    AnzahlQ=(Count('Gruppen', filter=Q(Gruppen__Eingeteilt=True)) + F('OffsetEinteilung'))
    #Definitionen
    MiniAnno = Mini.objects.annotate(Anzahl=AnzahlQ)
    minimum, maximum, minimum_Oberminis, maximum_Oberminis = __getMaxMin__(BlockQ, MiniAnno, MiniQ, OberminiQ)
    if minimum == None or minimum_Oberminis == None:
      BlockQ = Q(Q(Gruppen__Messe__Datum=MesseAktuell.Datum) | Q(Gruppen__Messe__Datum__range=(MesseAktuell.Datum, MesseAktuell.Datum - delta), Gruppen__Messe__autogenerated=True), Gruppen__Eingeteilt=True)
      minimum, maximum, minimum_Oberminis, maximum_Oberminis = __getMaxMin__(BlockQ, MiniAnno, MiniQ, OberminiQ)
    oberminis_akt = 0
    minis_akt = 0
    while minis_akt < MINIS_PRO_MESSE:
        sucheOberminis: bool = oberminis_akt < OBERMINIS_PRO_MESSE
        time_set_start = datetime.datetime.now()
        if sucheOberminis:
            # Falls alle Oberminis schon in blocked oder eingeteilt sind
            if minimum_Oberminis > maximum_Oberminis:  # Heisst, dass alle Oberminis, die schon im Topf sind nicht reichen => blockierten dazuholen
                blockOberminis = False
                minimum_Oberminis = MiniAnno.exclude(Gruppen__Messe=MesseAktuell, Gruppen__Eingeteilt=True).filter(OberminiQ).aggregate(Min('Anzahl'))['Anzahl__min'] # Muss beides aktualisiert werden, weil sich die Menge aendert
                maximum_Oberminis = MiniAnno.exclude(Gruppen__Messe=MesseAktuell, Gruppen__Eingeteilt=True).filter(OberminiQ).aggregate(Max('Anzahl'))['Anzahl__max']
            minisList = Mini.objects.filter(OberminiQ).exclude(Gruppen__Messe=MesseAktuell, Gruppen__Eingeteilt=True)
            #print(minisList)
            if blockOberminis:
               minisList = minisList.exclude(BlockQ)
               #print(minisList)
            #print(minisList)
            minisList = minisList.annotate(Anzahl=AnzahlQ).filter(Anzahl=minimum_Oberminis)
            #print(minisList)
        #Ab hier suche Minis
        else:
            if minimum > maximum: #Siehe Oberminis
                blockMinis = False
                minimum = MiniAnno.filter(MiniQ).exclude(Gruppen__Messe=MesseAktuell, Gruppen__Eingeteilt=True).aggregate(Min('Anzahl'))['Anzahl__min']
                maximum = MiniAnno.filter(MiniQ).exclude(Gruppen__Messe=MesseAktuell, Gruppen__Eingeteilt=True).aggregate(Max('Anzahl'))['Anzahl__max']
            minisList = Mini.objects.filter(MiniQ).exclude(Gruppen__Messe=MesseAktuell, Gruppen__Eingeteilt=True)
            #print(minisList)
            if blockMinis:
              minisList = minisList.exclude(BlockQ)
              #print(minisList)
            minisList = minisList.annotate(Anzahl=AnzahlQ).filter(Anzahl=minimum)
            #print(minisList)
        time_set_stop = datetime.datetime.now()
        #print("set", time_set_stop - time_set_start)
        #Waehle Gruppe
        gruppe: QuerySet[Gruppe]; ob_gruppe: int; minis_gruppe: int
        time_start = datetime.datetime.now()
        gruppe, ob_gruppe, minis_gruppe = __waehlePassendeGruppe__(minisList, minis_akt, oberminis_akt)
        time_stop = datetime.datetime.now()
        #print("choose", time_stop - time_start)
        ##print(gruppe, ob_gruppe, minis_gruppe)
        if gruppe == None:
            if sucheOberminis:
                minimum_Oberminis += 1
            else:
                minimum += 1
        else:
          #Erhöhe AnzahlEingeteilt
          oberminis_akt += ob_gruppe; minis_akt += minis_gruppe
    time_total_stop = datetime.datetime.now()
    #print("Total", time_total_stop - time_total)
    #Eingeilung fertig
    ##print(f'Messe {id} einteilen:')
    ##print(f'Minis: Expected {MINIS_PRO_MESSE}. ACTUAL {minis_akt}')
    ##print(f'Oberminis: Expected {OBERMINIS_PRO_MESSE}. ACTUAL {oberminis_akt}')
